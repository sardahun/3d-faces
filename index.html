<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>최대 공간 분할 분석기 V7</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020202; color: #fff; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(15,15,20,0.95); padding: 20px; border-radius: 12px; width: 280px; z-index: 100; border: 1px solid #00ff00; box-shadow: 0 0 20px rgba(0,255,0,0.2); }
        .stat { margin-bottom: 10px; font-size: 0.95rem; display: flex; justify-content: space-between; color: #00ff00; }
        .btn-group { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 15px; }
        button { padding: 12px; cursor: pointer; background: #1a1a1a; color: #fff; border: 1px solid #333; border-radius: 8px; font-weight: bold; transition: 0.2s; }
        button:hover { background: #00ff00; color: #000; }
        .primary { background: #00ff00 !important; color: #000 !important; }
        .desc { font-size: 0.8rem; color: #888; margin-top: 15px; line-height: 1.5; }
    </style>
</head>
<body>
    <div id="ui">
        <b style="font-size: 1.2rem; color: #00ff00;">MAX PARTITION V7</b>
        <hr style="border: 0; border-top: 1px solid #333; margin: 15px 0;">
        <div class="stat"><span>평면 개수 (N)</span> <span id="nCount">0</span></div>
        <div class="stat"><span>최대 가능 영역</span> <span id="maxPossible">0</span></div>
        <div class="stat"><span>실제 발견 영역</span> <span id="sCount">0</span></div>
        <div class="btn-group">
            <button onclick="addOptimizedPlane()" class="primary">최적 교차 평면 추가</button>
            <button onclick="navigateCells()" style="background:#ff3300; color:#fff; border:none;">영역 탐색 (축소 모드)</button>
            <button onclick="toggleView('plane')">평면 ON/OFF</button>
            <button onclick="toggleView('line')">교선 ON/OFF</button>
            <button onclick="location.reload()" style="opacity:0.6;">리셋</button>
        </div>
        <div class="desc">각 평면은 서로 평행하지 않게 배치되며, 모든 기존 평면과 교차하여 수학적 최대 영역을 형성합니다.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], lines = [];
        let validSignVectors = [], cellIndex = 0;
        let currentCell = null;
        let showP = true, showL = true;

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(1200, 1000, 1200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.PointLight(0xffffff, 1);
            sun.position.set(1000, 2000, 1000);
            scene.add(sun);
            animate();
        }

        // 모든 평면을 지나게 하는 정밀 배치 로직
        function addOptimizedPlane() {
            const n = planes.length;
            // 황금비 분할 기반의 고른 각도 배치 (서로 절대 평행하지 않게 함)
            const phi = Math.acos(-1 + (2 * n) / 10); 
            const theta = Math.sqrt(10 * Math.PI) * n;
            
            const normal = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ).normalize();

            // 모든 평면이 원점 근처에서 교차하도록 거리를 조절
            const d = (n % 2 === 0 ? 50 : -50) * (n + 1); 
            const plane = new THREE.Plane(normal, -d);

            const color = new THREE.Color().setHSL((n * 0.17) % 1, 0.8, 0.5);
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(30000, 30000),
                new THREE.MeshPhongMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity: 0.2, depthWrite: false })
            );
            mesh.lookAt(normal);
            mesh.position.copy(normal.clone().multiplyScalar(d));
            mesh.visible = showP;
            
            scene.add(mesh);
            planes.push({ plane, mesh, normal, color });

            updateIntersections();
            calculateAllCells();
            updateStats();
        }

        function calculateAllCells() {
            validSignVectors = [];
            const n = planes.length;
            const pts = [new THREE.Vector3(0,0,0)];

            // 교점 기반 정밀 샘플링
            for(let i=0; i<n; i++) {
                for(let j=i+1; j<n; j++) {
                    for(let k=j+1; k<n; k++) {
                        const p = getIntersection(planes[i].plane, planes[j].plane, planes[k].plane);
                        if(p) {
                            const offset = 5.0; // 오프셋 강화
                            pts.push(p);
                            for(let x of [-offset, offset]) for(let y of [-offset, offset]) for(let z of [-offset, offset]) {
                                pts.push(p.clone().add(new THREE.Vector3(x, y, z)));
                            }
                        }
                    }
                }
            }

            pts.forEach(p => {
                const vec = planes.map(pl => (p.dot(pl.normal) + pl.plane.constant > 0 ? 1 : -1));
                const key = vec.join(',');
                if(!validSignVectors.find(v => v.key === key)) {
                    validSignVectors.push({ key, vector: vec });
                }
            });
        }

        function getIntersection(p1, p2, p3) {
            const n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;
            const det = n1.clone().cross(n2).dot(n3);
            if(Math.abs(det) < 0.0001) return null;
            const res = n2.clone().cross(n3).multiplyScalar(-p1.constant)
                .add(n3.clone().cross(n1).multiplyScalar(-p2.constant))
                .add(n1.clone().cross(n2).multiplyScalar(-p3.constant))
                .divideScalar(det);
            return res;
        }

        function navigateCells() {
            if(validSignVectors.length === 0) return;
            if(currentCell) scene.remove(currentCell);

            const data = validSignVectors[cellIndex % validSignVectors.length];
            const clipPlanes = planes.map((p, i) => {
                const cp = new THREE.Plane().copy(p.plane);
                if(data.vector[i] === 1) cp.negate();
                cp.constant -= 15.0; // 영역 크기 대폭 축소 (Shrink)
                return cp;
            });

            const mat = new THREE.MeshPhongMaterial({
                color: 0x00ff00, emissive: 0x002200, side: THREE.DoubleSide,
                clippingPlanes: clipPlanes, shininess: 100
            });

            currentCell = new THREE.Mesh(new THREE.BoxGeometry(40000, 40000, 40000), mat);
            currentCell.renderOrder = 5000;
            scene.add(currentCell);
            
            cellIndex++;
            updateStats();
        }

        function updateIntersections() {
            lines.forEach(l => scene.remove(l));
            lines = [];
            const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
            for (let i = 0; i < planes.length; i++) {
                for (let j = i + 1; j < planes.length; j++) {
                    const p1 = planes[i].plane, p2 = planes[j].plane;
                    const dir = new THREE.Vector3().crossVectors(p1.normal, p2.normal);
                    if (dir.length() < 0.001) continue;
                    const m = new THREE.Matrix4().set(p1.normal.x, p1.normal.y, p1.normal.z, 0, p2.normal.x, p2.normal.y, p2.normal.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1).invert();
                    const pt = new THREE.Vector3(-p1.constant, -p2.constant, 0).applyMatrix4(m);
                    const geom = new THREE.BufferGeometry().setFromPoints([pt.clone().add(dir.clone().multiplyScalar(50000)), pt.clone().add(dir.clone().multiplyScalar(-50000))]);
                    const line = new THREE.Line(geom, mat);
                    line.visible = showL;
                    scene.add(line);
                    lines.push(line);
                }
            }
        }

        function toggleView(type) {
            if(type === 'plane') { showP = !showP; planes.forEach(p => p.mesh.visible = showP); }
            else { showL = !showL; lines.forEach(l => l.visible = showL); }
        }

        function updateStats() {
            const n = planes.length;
            const max = Math.round((n**3 + 5*n + 6) / 6);
            document.getElementById('nCount').innerText = n;
            document.getElementById('maxPossible').innerText = max;
            document.getElementById('sCount').innerText = validSignVectors.length;
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>
</html>
