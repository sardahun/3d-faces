<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>고정밀 공간 분할 V8</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #0f0; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,20,0,0.9); padding: 20px; border: 2px solid #0f0; border-radius: 5px; width: 300px; z-index: 100; }
        .stat { margin: 10px 0; font-size: 1rem; display: flex; justify-content: space-between; border-bottom: 1px dotted #0f0; }
        .btn-group { display: grid; gap: 10px; margin-top: 20px; }
        button { background: #000; color: #0f0; border: 1px solid #0f0; padding: 12px; cursor: pointer; font-weight: bold; }
        button:hover { background: #0f0; color: #000; }
        #log { font-size: 0.8rem; color: #0a0; margin-top: 10px; height: 60px; overflow-y: auto; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="font-size: 1.2rem; text-align: center; margin-bottom: 15px;">SPACE ANALYZER V8</div>
        <div class="stat"><span>평면 개수</span> <span id="nCount">0</span></div>
        <div class="stat"><span>이론적 최대</span> <span id="maxPossible">0</span></div>
        <div class="stat"><span>실제 발견</span> <span id="sCount">0</span></div>
        <div class="btn-group">
            <button onclick="addMaxPartitionPlane()">최적 평면 추가 (N++ )</button>
            <button onclick="navigateCells()" style="color: #ff0;">영역 정밀 탐색</button>
            <button onclick="togglePlanes()">평면 ON/OFF</button>
            <button onclick="location.reload()">시스템 리셋</button>
        </div>
        <div id="log">Ready...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], lines = [];
        let validCells = [], cellIdx = 0, currentCellMesh = null;
        let showP = true;

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(2000, 1500, 2000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const pLight = new THREE.PointLight(0xffffff, 1);
            pLight.position.set(5000, 5000, 5000);
            scene.add(pLight);

            animate();
        }

        function addMaxPartitionPlane() {
            const n = planes.length;
            // 각 평면이 서로 독립적인 각도를 갖도록 피보나치 구면 분포 활용
            const offset = 2 / 10;
            const increment = Math.PI * (3 - Math.sqrt(5));
            const y = ((n * offset) - 1) + (offset / 2);
            const r = Math.sqrt(1 - Math.pow(y, 2));
            const phi = n * increment;

            const normal = new THREE.Vector3(Math.cos(phi) * r, y, Math.sin(phi) * r).normalize();
            const d = (n % 2 === 0 ? 80 : -80) * (n + 1); // 원점에서 엇갈리게 배치
            
            const plane = new THREE.Plane(normal, -d);
            const color = new THREE.Color().setHSL((n * 0.21) % 1, 0.8, 0.5);
            
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(50000, 50000),
                new THREE.MeshPhongMaterial({ color, side: THREE.DoubleSide, transparent: true, opacity: 0.15, depthWrite: false })
            );
            mesh.lookAt(normal);
            mesh.position.copy(normal.clone().multiplyScalar(d));
            mesh.visible = showP;
            
            scene.add(mesh);
            planes.push({ plane, mesh, normal, color });

            updateIntersections();
            findCellsBruteForce();
            updateUI();
        }

        // 고정밀 전수 조사 알고리즘
        function findCellsBruteForce() {
            validCells = [];
            const n = planes.length;
            const intersectionPoints = [];

            // 1. 모든 3개 평면의 교점 수집
            for(let i=0; i<n; i++) {
                for(let j=i+1; j<n; j++) {
                    for(let k=j+1; k<n; k++) {
                        const pt = getPointFrom3Planes(planes[i].plane, planes[j].plane, planes[k].plane);
                        if(pt) intersectionPoints.push(pt);
                    }
                }
            }

            // 2. 모든 교점의 중점(Centroid) 및 오프셋 샘플 생성
            const testPoints = [new THREE.Vector3(0,0,0)];
            intersectionPoints.forEach(p => {
                testPoints.push(p);
                // 교점으로부터 아주 작은 거리에 있는 8방향 점 테스트 (영역 진입용)
                const eps = 2.0;
                for(let x of [-eps, eps]) for(let y of [-eps, eps]) for(let z of [-eps, eps]) {
                    testPoints.push(p.clone().add(new THREE.Vector3(x, y, z)));
                }
            });

            // 3. 중복 제거 및 유효 영역 판별
            const foundKeys = new Set();
            testPoints.forEach(p => {
                const signVector = planes.map(pl => (p.dot(pl.normal) + pl.plane.constant > 0 ? 1 : -1));
                const key = signVector.join(',');
                if(!foundKeys.has(key)) {
                    foundKeys.add(key);
                    validCells.push(signVector);
                }
            });
            
            document.getElementById('log').innerText = `Analysis: Found ${validCells.length} unique regions.`;
        }

        function getPointFrom3Planes(p1, p2, p3) {
            const m = new THREE.Matrix3().set(
                p1.normal.x, p1.normal.y, p1.normal.z,
                p2.normal.x, p2.normal.y, p2.normal.z,
                p3.normal.x, p3.normal.y, p3.normal.z
            );
            const det = m.determinant();
            if(Math.abs(det) < 0.0001) return null;

            const v1 = p1.normal, v2 = p2.normal, v3 = p3.normal;
            const res = new THREE.Vector3()
                .add(v2.clone().cross(v3).multiplyScalar(-p1.constant))
                .add(v3.clone().cross(v1).multiplyScalar(-p2.constant))
                .add(v1.clone().cross(v2).multiplyScalar(-p3.constant))
                .divideScalar(det);
            return res;
        }

        function navigateCells() {
            if(validCells.length === 0) return;
            if(currentCellMesh) scene.remove(currentCellMesh);

            const signVector = validCells[cellIdx % validCells.length];
            const clippingPlanes = planes.map((p, i) => {
                const cp = new THREE.Plane().copy(p.plane);
                if(signVector[i] === 1) cp.negate();
                cp.constant -= 25.0; // 영역 부피를 대폭 축소하여 가독성 확보
                return cp;
            });

            const geom = new THREE.BoxGeometry(60000, 60000, 60000);
            const mat = new THREE.MeshPhongMaterial({
                color: 0x00ff00, emissive: 0x004400, side: THREE.DoubleSide,
                clippingPlanes: clippingPlanes, shininess: 100
            });

            currentCellMesh = new THREE.Mesh(geom, mat);
            currentCellMesh.renderOrder = 9999;
            scene.add(currentCellMesh);

            cellIdx++;
            document.getElementById('log').innerText = `Viewing Region: ${cellIdx} / ${validCells.length}`;
        }

        function updateIntersections() {
            lines.forEach(l => scene.remove(l));
            lines = [];
            const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
            for (let i = 0; i < planes.length; i++) {
                for (let j = i + 1; j < planes.length; j++) {
                    const p1 = planes[i].plane, p2 = planes[j].plane;
                    const dir = new THREE.Vector3().crossVectors(p1.normal, p2.normal);
                    if (dir.length() < 0.01) continue;
                    
                    // 두 평면의 교선을 구하기 위한 임시 행렬 계산
                    const m = new THREE.Matrix4().set(
                        p1.normal.x, p1.normal.y, p1.normal.z, 0,
                        p2.normal.x, p2.normal.y, p2.normal.z, 0,
                        dir.x, dir.y, dir.z, 0, 0, 0, 0, 1
                    ).invert();
                    const pt = new THREE.Vector3(-p1.constant, -p2.constant, 0).applyMatrix4(m);
                    
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        pt.clone().add(dir.clone().multiplyScalar(50000)),
                        pt.clone().add(dir.clone().multiplyScalar(-50000))
                    ]);
                    const line = new THREE.Line(geom, mat);
                    scene.add(line);
                    lines.push(line);
                }
            }
        }

        function togglePlanes() {
            showP = !showP;
            planes.forEach(p => p.mesh.visible = showP);
        }

        function updateUI() {
            const n = planes.length;
            const max = Math.round((n**3 + 5*n + 6) / 6);
            document.getElementById('nCount').innerText = n;
            document.getElementById('maxPossible').innerText = max;
            document.getElementById('sCount').innerText = validCells.length;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
