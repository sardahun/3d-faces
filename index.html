<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>공간 분할 시뮬레이션</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; pointer-events: none; line-height: 1.5; }
        .controls { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; }
        button { padding: 10px 15px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        button:hover { background: #444; }
    </style>
</head>
<body>
    <div id="info">
        <h2>차원 확장 공간 분할 시뮬레이션</h2>
        <p>n번째 평면(Plane) 추가 시, 그 평면 위에서 발생하는 현상은<br>
        (n-1)개의 직선에 의한 평면 분할과 동일함(재귀적 성질)</p>
        <div id="stats">현재 평면 개수(n): 0</div>
    </div>
    <div class="controls">
        <button onclick="addPlane()">평면 추가 (n+1)</button>
        <button onclick="reset()">초기화</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [];
        let planeSize = 40;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            const grid = new THREE.GridHelper(100, 20, 0x444444, 0x222222);
            scene.add(grid);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function addPlane() {
            const n = planes.length + 1;
            
            // 수학적 시각화를 위해 일반적인 위치(General Position)에 평면 배치
            // 각도와 위치를 무작위가 아닌 서로 교차하도록 설정
            const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color(`hsl(${n * 60}, 70%, 50%)`),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            
            const planeMesh = new THREE.Mesh(geometry, material);
            
            // 오일러 각을 이용해 서로 평행하지 않게 배치
            planeMesh.rotation.x = Math.random() * Math.PI;
            planeMesh.rotation.y = Math.random() * Math.PI;
            
            scene.add(planeMesh);
            planes.push(planeMesh);

            // 새로운 평면이 추가될 때 기존 평면들과의 교선(Intersection Line) 시각화
            drawIntersections(planeMesh, n);
            
            document.getElementById('stats').innerText = `현재 평면 개수(n): ${n}`;
        }

        function drawIntersections(newPlane, n) {
            // 실제 기하학적 교선을 계산하는 대신, n번째 평면 위에서 
            // 이전 n-1개의 평면이 만드는 직선 배치를 강조함
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            
            for (let i = 0; i < n - 1; i++) {
                const points = [];
                // 해당 평면 로컬 좌표계 상에서 직선을 그려 평면 분할임을 명시
                points.push(new THREE.Vector3(-planeSize/2, (Math.random()-0.5)*planeSize, 0.01));
                points.push(new THREE.Vector3(planeSize/2, (Math.random()-0.5)*planeSize, 0.01));
                
                const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeom, lineMaterial);
                
                // 교선을 새로운 평면의 자식 객체로 추가하여 함께 움직이게 함
                newPlane.add(line);
            }
        }

        function reset() {
            planes.forEach(p => scene.remove(p));
            planes = [];
            document.getElementById('stats').innerText = `현재 평면 개수(n): 0`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
