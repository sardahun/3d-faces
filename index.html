<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>고정밀 공간 분석기 V4</title>
    <style>
        :root { --bg: #ffffff; --panel: rgba(240,240,240,0.9); --text: #000000; --accent: #007aff; }
        body.dark { --bg: #0a0a0b; --panel: rgba(30,30,35,0.95); --text: #ffffff; --accent: #00d4ff; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--text); font-family: sans-serif; transition: 0.3s; }
        #ui { position: absolute; top: 20px; left: 20px; background: var(--panel); padding: 20px; border-radius: 12px; width: 260px; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
        .stat { margin-bottom: 8px; font-size: 0.85rem; display: flex; justify-content: space-between; }
        .btn-group { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 15px; }
        button { padding: 10px; cursor: pointer; background: var(--accent); color: white; border: none; border-radius: 6px; font-weight: bold; }
        button.sub { background: #666; }
        hr { border: 0; border-top: 1px solid #ccc; margin: 15px 0; }
    </style>
</head>
<body class="dark">
    <div id="ui">
        <b id="title">공간 분석기 V4</b>
        <div class="btn-group">
            <button onclick="toggleTheme()" class="sub">테마 전환 (Light/Dark)</button>
        </div>
        <hr>
        <div class="stat"><span>평면 수</span> <span id="nCount">0</span></div>
        <div class="stat"><span>발견된 영역</span> <span id="sCount">0</span></div>
        <div class="stat"><span>현재 영역</span> <span id="cellIdx">None</span></div>
        <div class="btn-group">
            <button onclick="addPlane()">평면 추가 (+)</button>
            <button onclick="togglePlanes()" class="sub">평면 ON/OFF</button>
            <button onclick="navigateCells()">영역 탐색 (순차)</button>
            <button onclick="hideCurrentCell()" class="sub">영역 끄기</button>
            <button onclick="location.reload()" style="background:#ff4444;">초기화</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], intersectionLines = [];
        let validSignVectors = [], cellIndex = 0;
        let currentCell = null, showPlanes = true;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 50000);
            camera.position.set(1200, 1000, 1200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(500, 1000, 500);
            scene.add(sun);

            animate();
        }

        function toggleTheme() {
            document.body.classList.toggle('dark');
            const isDark = document.body.classList.contains('dark');
            planes.forEach(p => {
                p.mesh.material.color.set(isDark ? 0x444444 : 0xaaaaaa);
            });
        }

        function addPlane() {
            const normal = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const d = (Math.random() - 0.5) * 300;
            const plane = new THREE.Plane(normal, -d);

            const mat = new THREE.MeshPhongMaterial({
                color: document.body.classList.contains('dark') ? 0x444444 : 0xaaaaaa,
                side: THREE.DoubleSide, transparent: true, opacity: 0.2, depthWrite: false
            });

            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), mat);
            mesh.lookAt(normal);
            mesh.position.copy(normal.clone().multiplyScalar(d));
            mesh.visible = showPlanes;
            
            scene.add(mesh);
            planes.push({ plane, mesh, normal, d });

            updateIntersections();
            findAllCells();
            updateStats();
        }

        function togglePlanes() {
            showPlanes = !showPlanes;
            planes.forEach(p => p.mesh.visible = showPlanes);
            intersectionLines.forEach(l => l.visible = showPlanes);
        }

        function updateIntersections() {
            intersectionLines.forEach(l => scene.remove(l));
            intersectionLines = [];
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });

            for (let i = 0; i < planes.length; i++) {
                for (let j = i + 1; j < planes.length; j++) {
                    const p1 = planes[i].plane, p2 = planes[j].plane;
                    const dir = new THREE.Vector3().crossVectors(p1.normal, p2.normal);
                    if (dir.length() < 0.001) continue;

                    const m = new THREE.Matrix4().set(
                        p1.normal.x, p1.normal.y, p1.normal.z, 0,
                        p2.normal.x, p2.normal.y, p2.normal.z, 0,
                        dir.x, dir.y, dir.z, 0, 0, 0, 0, 1
                    ).invert();
                    const pt = new THREE.Vector3(-p1.constant, -p2.constant, 0).applyMatrix4(m);
                    
                    const geom = new THREE.BufferGeometry().setFromPoints([
                        pt.clone().add(dir.clone().multiplyScalar(5000)),
                        pt.clone().add(dir.clone().multiplyScalar(-5000))
                    ]);
                    const line = new THREE.Line(geom, lineMat);
                    line.visible = showPlanes;
                    scene.add(line);
                    intersectionLines.push(line);
                }
            }
        }

        function findAllCells() {
            validSignVectors = [];
            const samples = [];
            // 모든 3개 평면 교점 추출
            for(let i=0; i<planes.length; i++) {
                for(let j=i+1; j<planes.length; j++) {
                    for(let k=j+1; k<planes.length; k++) {
                        const pt = getInt(planes[i].plane, planes[j].plane, planes[k].plane);
                        if(pt) {
                            const eps = 1.0;
                            for(let x of [-eps, eps]) for(let y of [-eps, eps]) for(let z of [-eps, eps]) {
                                samples.push(pt.clone().add(new THREE.Vector3(x,y,z)));
                            }
                        }
                    }
                }
            }
            // 원점 근처 보조 샘플링
            for(let x=-400; x<=400; x+=100) for(let y=-400; y<=400; y+=100) for(let z=-400; z<=400; z+=100) samples.push(new THREE.Vector3(x,y,z));

            samples.forEach(p => {
                const vec = planes.map(pl => (p.dot(pl.normal) + pl.plane.constant > 0 ? 1 : -1));
                const key = vec.join(',');
                if(!validSignVectors.find(v => v.key === key)) {
                    validSignVectors.push({ key, vector: vec });
                }
            });
        }

        function getInt(p1, p2, p3) {
            const n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;
            const det = n1.clone().cross(n2).dot(n3);
            if(Math.abs(det) < 0.001) return null;
            return n2.clone().cross(n3).multiplyScalar(-p1.constant)
                .add(n3.clone().cross(n1).multiplyScalar(-p2.constant))
                .add(n1.clone().cross(n2).multiplyScalar(-p3.constant))
                .divideScalar(det);
        }

        function navigateCells() {
            if(validSignVectors.length === 0) return;
            hideCurrentCell();

            const data = validSignVectors[cellIndex % validSignVectors.length];
            const clipPlanes = planes.map((p, i) => {
                const cp = new THREE.Plane().copy(p.plane);
                if(data.vector[i] === 1) cp.negate();
                cp.constant -= 0.5; // 폐곡면 보정 마진 확대
                return cp;
            });

            const geom = new THREE.BoxGeometry(10000, 10000, 10000);
            const mat = new THREE.MeshPhongMaterial({
                color: 0xff3300, emissive: 0x440000, side: THREE.DoubleSide,
                clippingPlanes: clipPlanes,
                polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: -2
            });

            currentCell = new THREE.Mesh(geom, mat);
            currentCell.renderOrder = 999; // 평면보다 우선순위 높임
            scene.add(currentCell);
            
            cellIndex++;
            updateStats();
        }

        function hideCurrentCell() {
            if(currentCell) {
                currentCell.geometry.dispose();
                currentCell.material.dispose();
                scene.remove(currentCell);
                currentCell = null;
            }
            updateStats();
        }

        function updateStats() {
            document.getElementById('nCount').innerText = planes.length;
            document.getElementById('sCount').innerText = validSignVectors.length;
            document.getElementById('cellIdx').innerText = currentCell ? `${(cellIndex-1) % validSignVectors.length + 1}` : "None";
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
