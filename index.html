<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정밀 영역 분석 도구 - V3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(10,10,10,0.95); padding: 20px; border-radius: 12px; border: 1px solid #00d4ff; width: 260px; z-index: 100; box-shadow: 0 0 20px rgba(0,212,255,0.2); }
        .stat { margin-bottom: 8px; font-size: 0.85rem; color: #00d4ff; display: flex; justify-content: space-between; }
        .btn-group { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 15px; }
        button { padding: 12px; cursor: pointer; background: #1a1a1a; color: #fff; border: 1px solid #333; border-radius: 6px; font-weight: bold; transition: 0.3s; }
        button:hover { background: #00d4ff; color: #000; }
        .desc { font-size: 0.7rem; color: #666; margin-top: 12px; text-align: center; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 15px; color: #00d4ff;">고정밀 공간 분석기</div>
        <div class="stat"><span>평면 수 (n)</span> <span id="nCount">0</span></div>
        <div class="stat"><span>발견된 영역</span> <span id="sCount">0</span></div>
        <div class="stat"><span>현재 탐색</span> <span id="cellIdx">0</span></div>
        <div class="btn-group">
            <button onclick="addOptimizedPlane()">평면 추가</button>
            <button onclick="navigateCells()" style="border-color: #00d4ff;">영역 탐색</button>
            <button onclick="hideCurrentCell()">영역 표시 끄기</button>
            <button onclick="resetAll()" style="color: #ff4444;">초기화</button>
        </div>
        <div class="desc">※ 미세 축소(Shrink) 기술로 Z-fighting 해결</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], intersectionLines = [];
        let currentCellMesh = null;
        let cellIndex = 0, validSignVectors = [];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 30000);
            camera.position.set(800, 600, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.PointLight(0xffffff, 1);
            light.position.set(1000, 1000, 1000);
            scene.add(light);

            animate();
        }

        function addOptimizedPlane() {
            const n = planes.length;
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.acos(2 * Math.random() - 1);
            const normal = new THREE.Vector3(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));
            const d = (Math.random() - 0.5) * 200; // 원점 근처로 모아서 닫힌 공간 유도

            const plane = new THREE.Plane(normal, -d);
            const helper = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshPhongMaterial({
                color: 0x333333, side: THREE.DoubleSide, transparent: true, opacity: 0.05
            }));
            helper.lookAt(normal);
            helper.position.copy(normal.clone().multiplyScalar(d));
            scene.add(helper);

            planes.push({ plane, mesh: helper, normal, d });
            updateIntersections();
            findAllCells();
            hideCurrentCell();
            updateStats();
        }

        function findAllCells() {
            validSignVectors = [];
            const n = planes.length;
            const samples = [];

            // 전략 1: 모든 3개 평면의 교점 주변 샘플링
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    for (let k = j + 1; k < n; k++) {
                        const pt = calculateThreePlaneIntersection(planes[i].plane, planes[j].plane, planes[k].plane);
                        if (pt) {
                            const eps = 0.5;
                            for(let x of [-eps, eps]) for(let y of [-eps, eps]) for(let z of [-eps, eps]) {
                                samples.push(pt.clone().add(new THREE.Vector3(x, y, z)));
                            }
                        }
                    }
                }
            }
            // 전략 2: 원점 근처 그리드 샘플링 (누락 방지)
            for(let x=-300; x<=300; x+=100) for(let y=-300; y<=300; y+=100) for(let z=-300; z<=300; z+=100) {
                samples.push(new THREE.Vector3(x, y, z));
            }

            samples.forEach(pt => {
                const vec = planes.map(p => (pt.dot(p.normal) + p.plane.constant > 0 ? 1 : -1));
                const key = vec.join(',');
                if (!validSignVectors.some(v => v.key === key)) {
                    validSignVectors.push({ key, vector: vec, center: pt.clone() });
                }
            });
        }

        function calculateThreePlaneIntersection(p1, p2, p3) {
            const n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;
            const det = n1.clone().cross(n2).dot(n3);
            if (Math.abs(det) < 0.0001) return null;
            const v1 = n2.clone().cross(n3).multiplyScalar(-p1.constant);
            const v2 = n3.clone().cross(n1).multiplyScalar(-p2.constant);
            const v3 = n1.clone().cross(n2).multiplyScalar(-p3.constant);
            return new THREE.Vector3().add(v1).add(v2).add(v3).divideScalar(det);
        }

        function navigateCells() {
            if (validSignVectors.length === 0) return;
            hideCurrentCell();

            const data = validSignVectors[cellIndex % validSignVectors.length];
            const size = 10000;
            const geom = new THREE.BoxGeometry(size, size, size);
            
            // Z-fighting 해결 핵심: 클리핑 평면을 아주 미세하게 안쪽으로 밀어넣음 (Inset)
            const inset = 0.05; 
            const clipPlanes = planes.map((p, i) => {
                const s = data.vector[i];
                const plane = new THREE.Plane().copy(p.plane);
                if (s === 1) plane.negate(); 
                plane.constant -= inset; // 영역을 미세하게 깎아 평면과 분리
                return plane;
            });

            const mat = new THREE.MeshPhongMaterial({
                color: 0x00d4ff, emissive: 0x004466, side: THREE.DoubleSide,
                transparent: true, opacity: 0.8,
                clippingPlanes: clipPlanes,
                clipShadows: true
            });

            currentCellMesh = new THREE.Mesh(geom, mat);
            scene.add(currentCellMesh);
            
            cellIndex++;
            updateStats();
        }

        function hideCurrentCell() {
            if (currentCellMesh) {
                currentCellMesh.geometry.dispose();
                currentCellMesh.material.dispose();
                scene.remove(currentCellMesh);
                currentCellMesh = null;
            }
            updateStats();
        }

        function updateIntersections() {
            intersectionLines.forEach(l => scene.remove(l));
            intersectionLines = [];
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
            for (let i = 0; i < planes.length; i++) {
                for (let j = i + 1; j < planes.length; j++) {
                    const p1 = planes[i].plane, p2 = planes[j].plane;
                    const dir = new THREE.Vector3().crossVectors(p1.normal, p2.normal);
                    if (dir.length() < 0.01) continue;
                    const m = new THREE.Matrix4().set(p1.normal.x, p1.normal.y, p1.normal.z, 0, p2.normal.x, p2.normal.y, p2.normal.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1).invert();
                    const pt = new THREE.Vector3(-p1.constant, -p2.constant, 0).applyMatrix4(m);
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([pt.clone().add(dir.clone().multiplyScalar(5000)), pt.clone().add(dir.clone().multiplyScalar(-5000))]);
                    const line = new THREE.Line(lineGeom, mat);
                    scene.add(line);
                    intersectionLines.push(line);
                }
            }
        }

        function updateStats() {
            document.getElementById('nCount').innerText = planes.length;
            document.getElementById('sCount').innerText = validSignVectors.length;
            document.getElementById('cellIdx').innerText = currentCellMesh ? (cellIndex - 1) % validSignVectors.length + 1 : 0;
        }

        function resetAll() {
            location.reload();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
