<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정밀 공간 분할 시뮬레이터</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: #fff; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 8px; border: 1px solid #444; width: 280px; z-index: 100; }
        .stat { margin-bottom: 10px; font-size: 0.9rem; color: #00d4ff; }
        .btn-group { display: grid; grid-template-columns: 1fr; gap: 8px; }
        button { padding: 10px; cursor: pointer; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; transition: 0.2s; }
        button:hover { background: #333; border-color: #00d4ff; }
        .desc { font-size: 0.75rem; color: #888; margin-top: 10px; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 5px;">공간 분할 정밀 분석</div>
        <div class="stat">평면 수 (n): <span id="nCount">0</span></div>
        <div class="stat">현재 영역 번호: <span id="cellIdx">-</span> / <span id="sCount">1</span></div>
        <div class="btn-group">
            <button onclick="addOptimizedPlane()">최적 평면 추가 (Max Division)</button>
            <button onclick="togglePlanes()">평면 표시 전환 (ON/OFF)</button>
            <button onclick="nextCell()" style="background: #004466;">다음 영역 탐색 (Cell Clipping)</button>
            <button onclick="resetAll()">초기화</button>
        </div>
        <div class="desc">탐색 시 평면들에 의해 실제로 절단된 공간의 형태(Convex Polyhedron)를 시뮬레이션한다.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], intersectionLines = [], currentCellMesh = null;
        let showPlanes = true, currentCellSeed = 0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(180, 150, 180);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(100, 200, 100);
            scene.add(sun);

            animate();
        }

        function addOptimizedPlane() {
            const n = planes.length;
            // 일반적 위치 보장: 각도를 순차적으로 비틀어 중복 교차 방지
            const phi = n * 137.5 * (Math.PI / 180); // 황금각 기반 분산
            const theta = Math.acos(1 - 2 * (n / 10)); 
            
            const normal = new THREE.Vector3(
                Math.sin(theta) * Math.cos(phi),
                Math.sin(theta) * Math.sin(phi),
                Math.cos(theta)
            ).normalize();

            // 원점 통과 방지 및 일정한 간격 유지를 위한 오프셋 d
            const d = (n + 1) * 15 * (n % 2 === 0 ? 1 : -1);

            const plane = new THREE.Plane(normal, -d);
            const helperGeom = new THREE.PlaneGeometry(500, 500);
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL((n * 0.15) % 1, 0.6, 0.5),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.25,
                visible: showPlanes
            });

            const mesh = new THREE.Mesh(helperGeom, material);
            mesh.lookAt(normal);
            mesh.position.copy(normal.clone().multiplyScalar(d));
            
            scene.add(mesh);
            planes.push({ plane, mesh, normal, d });

            updateIntersections();
            updateStats();
        }

        function updateIntersections() {
            intersectionLines.forEach(l => scene.remove(l));
            intersectionLines = [];
            const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff88, opacity: 0.6, transparent: true });

            for (let i = 0; i < planes.length; i++) {
                for (let j = i + 1; j < planes.length; j++) {
                    const p1 = planes[i].plane, p2 = planes[j].plane;
                    const lineDir = new THREE.Vector3().crossVectors(p1.normal, p2.normal);
                    if (lineDir.length() < 0.001) continue;

                    const linePoint = new THREE.Vector3();
                    const m = new THREE.Matrix4().set(
                        p1.normal.x, p1.normal.y, p1.normal.z, 0,
                        p2.normal.x, p2.normal.y, p2.normal.z, 0,
                        lineDir.x, lineDir.y, lineDir.z, 0,
                        0, 0, 0, 1
                    );
                    const invM = m.invert();
                    linePoint.set(-p1.constant, -p2.constant, 0).applyMatrix4(invM);

                    const geom = new THREE.BufferGeometry().setFromPoints([
                        linePoint.clone().add(lineDir.clone().multiplyScalar(1000)),
                        linePoint.clone().add(lineDir.clone().multiplyScalar(-1000))
                    ]);
                    const line = new THREE.Line(geom, lineMat);
                    scene.add(line);
                    intersectionLines.push(line);
                }
            }
        }

        function nextCell() {
            if (planes.length < 2) return;
            if (currentCellMesh) scene.remove(currentCellMesh);

            const n = planes.length;
            const maxS = Math.round((n**3 + 5*n + 6)/6);
            currentCellSeed = (currentCellSeed + 1) % maxS;
            document.getElementById('cellIdx').innerText = currentCellSeed + 1;

            // CSG 개념을 응용하여 평면들에 의해 절단된 기하체(Box 기반) 생성
            const boxSize = 400;
            let cellGeom = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xff4400, 
                transparent: true, 
                opacity: 0.8,
                shininess: 100
            });

            currentCellMesh = new THREE.Mesh(cellGeom, material);
            
            // 시각적 효과를 위해 임의의 분할 영역으로 이동
            const randomOffset = new THREE.Vector3(
                Math.sin(currentCellSeed * 1.5) * 40,
                Math.cos(currentCellSeed * 2.1) * 40,
                Math.sin(currentCellSeed * 0.7) * 40
            );
            currentCellMesh.position.copy(randomOffset);

            // 영역 절단(Clipping) 시각화: 평면 밖의 부분을 가상으로 도려냄
            const clipPlanes = planes.map(p => {
                const side = (randomOffset.dot(p.normal) + p.plane.constant > 0) ? 1 : -1;
                return new THREE.Plane(p.normal.clone().multiplyScalar(side), p.plane.constant * side);
            });
            
            renderer.localClippingEnabled = true;
            currentCellMesh.material.clippingPlanes = clipPlanes;

            scene.add(currentCellMesh);
        }

        function togglePlanes() {
            showPlanes = !showPlanes;
            planes.forEach(p => p.mesh.material.visible = showPlanes);
        }

        function updateStats() {
            const n = planes.length;
            document.getElementById('nCount').innerText = n;
            document.getElementById('sCount').innerText = Math.round((n**3 + 5*n + 6)/6);
        }

        function resetAll() {
            planes.forEach(p => scene.remove(p.mesh));
            intersectionLines.forEach(l => scene.remove(l));
            if (currentCellMesh) scene.remove(currentCellMesh);
            planes = []; intersectionLines = []; currentCellSeed = 0;
            updateStats();
            document.getElementById('cellIdx').innerText = "-";
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
