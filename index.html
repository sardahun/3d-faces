<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>3D Space Partition V10 (nC0~nC3)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #00ffcc; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,30,30,0.9); padding: 20px; border: 1px solid #00ffcc; border-radius: 8px; width: 300px; z-index: 100; }
        .stat { display: flex; justify-content: space-between; margin: 8px 0; font-size: 0.95rem; }
        .formula { font-style: italic; color: #ffcc00; font-size: 0.8rem; margin-bottom: 10px; }
        button { width: 100%; padding: 10px; margin-top: 8px; background: transparent; border: 1px solid #00ffcc; color: #00ffcc; cursor: pointer; font-weight: bold; }
        button:hover { background: #00ffcc; color: #000; }
        #log { font-size: 0.8rem; color: #00aa88; margin-top: 10px; border-top: 1px solid #004444; padding-top: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 5px;">공간 분할 분석기 V10</div>
        <div class="formula">Regions = nC0 + nC1 + nC2 + nC3</div>
        <hr style="border:0; border-top:1px solid #004444;">
        <div class="stat"><span>평면 개수 (n)</span> <span id="nVal">0</span></div>
        <div class="stat"><span>이론적 최대 영역</span> <span id="maxVal">0</span></div>
        <div class="stat"><span>검출된 영역 개수</span> <span id="foundVal" style="color:#fff;">0</span></div>
        <button onclick="addPlane()">평면 추가 (모든 면 교차)</button>
        <button onclick="navigate()" style="border-color:#ffcc00; color:#ffcc00;">영역 탐색 (부피 축소)</button>
        <div id="log">평면을 추가하여 분석을 시작하세요.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let planes = [], validRegions = [], currentMesh = null, cIdx = 0;

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 100000);
            camera.position.set(2000, 1800, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const l = new THREE.PointLight(0xffffff, 1); l.position.set(3000, 5000, 3000); scene.add(l);
            animate();
        }

        function addPlane() {
            const n = planes.length;
            // nC3 분할을 극대화하기 위한 각도 (비대칭성 확보)
            const angle = n * 137.5 * (Math.PI / 180); 
            const tilt = Math.acos(1 - 2 * (n / 10));
            const normal = new THREE.Vector3(Math.sin(tilt)*Math.cos(angle), Math.cos(tilt), Math.sin(tilt)*Math.sin(angle)).normalize();
            const d = (n % 2 === 0 ? 100 : -100) * (n + 1);
            
            const plane = new THREE.Plane(normal, -d);
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(50000, 50000), 
                new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(n*0.25, 0.7, 0.5), transparent: true, opacity: 0.1, side: THREE.DoubleSide, depthWrite: false }));
            mesh.lookAt(normal);
            mesh.position.copy(normal.clone().multiplyScalar(d));
            scene.add(mesh);
            planes.push({ plane, normal });

            calculateRegions();
            updateUI();
        }

        function calculateRegions() {
            validRegions = [];
            const n = planes.length;
            const pts = [new THREE.Vector3(0,0,0)];

            // 모든 3개 평면의 교점(Vertex) 추출
            for(let i=0; i<n; i++) {
                for(let j=i+1; j<n; j++) {
                    for(let k=j+1; k<n; k++) {
                        const p = intersect3(planes[i].plane, planes[j].plane, planes[k].plane);
                        if(p) {
                            pts.push(p);
                            // 교점 중심 사방 샘플링으로 nC0~nC3 영역 모두 타격
                            for(let x of [-5, 5]) for(let y of [-5, 5]) for(let z of [-5, 5]) {
                                pts.push(p.clone().add(new THREE.Vector3(x,y,z)));
                            }
                        }
                    }
                }
            }

            const foundKeys = new Set();
            pts.forEach(p => {
                const vec = planes.map(pl => (p.dot(pl.normal) + pl.plane.constant > 0.01 ? 1 : -1));
                const key = vec.join(',');
                if(!foundKeys.has(key)) {
                    foundKeys.add(key);
                    validRegions.push(vec);
                }
            });
        }

        function intersect3(p1, p2, p3) {
            const n1 = p1.normal, n2 = p2.normal, n3 = p3.normal;
            const det = n1.clone().cross(n2).dot(n3);
            if(Math.abs(det) < 0.001) return null;
            return n2.clone().cross(n3).multiplyScalar(-p1.constant)
                .add(n3.clone().cross(n1).multiplyScalar(-p2.constant))
                .add(n1.clone().cross(n2).multiplyScalar(-p3.constant)).divideScalar(det);
        }

        function navigate() {
            if(validRegions.length === 0) return;
            if(currentMesh) scene.remove(currentMesh);

            const vec = validRegions[cIdx % validRegions.length];
            const clips = planes.map((p, i) => {
                const cp = new THREE.Plane().copy(p.plane);
                if(vec[i] === 1) cp.negate();
                cp.constant -= 35.0; // 영역간 간섭 방지를 위한 Shrink
                return cp;
            });

            currentMesh = new THREE.Mesh(new THREE.BoxGeometry(60000, 60000, 60000), 
                new THREE.MeshPhongMaterial({ color: 0x00ffcc, emissive: 0x004433, side: THREE.DoubleSide, clippingPlanes: clips }));
            scene.add(currentMesh);
            
            document.getElementById('log').innerText = `영역 ${cIdx % validRegions.length + 1} / ${validRegions.length} 표시 중...`;
            cIdx++;
        }

        function updateUI() {
            const n = planes.length;
            const max = Math.round((n**3 + 5*n + 6) / 6); // nC0 + nC1 + nC2 + nC3
            document.getElementById('nVal').innerText = n;
            document.getElementById('maxVal').innerText = max;
            document.getElementById('foundVal').innerText = validRegions.length;
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>
</html>
